#include "ssa.hh"

#include <cassert>
#include <iostream>
#include <list>
#include <stack>
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <vector>

#include "block_graph.hh"
#include "graph.hh"
#include "ir_printer.hh"
#include "liveness.hh"

using liveness::LivenessAnalysis;

void SSAWorker::ResetTables() {
    dominators_.clear();
    tree_dominators_.clear();
    dominance_frontiers_.clear();
    reverse_graph_.clear();
    local_to_op_.clear();
}

Box<ir::Prog> SSAWorker::Launch(Box<ir::Prog> prog) {
    for (auto& fun : prog->funcs()) {
        ResetTables();
        CombineAddr(fun);
        PointerToReg(fun);

        auto block_graph = BlockGraph::FromBlocks(fun->blocks());
        auto graph = block_graph->graph();
        block_graph->GenerateSingleSourceGraph(graph.nodes().at(0), fun);

        liveness_.Launch(graph.nodes().at(0), graph, fun->args());
        liveness_.DisplayLiveness(stdout, graph);

        exit(0);

        for (const auto& [id, node] : block_graph->graph().nodes()) {
            reverse_graph_[node->element()] = node;
        }

        Dominators(graph);
        DeriveTreeDominators(graph);
        DeriveDominaceFroniters(graph, graph.nodes().at(0));

        // PlacePhiFunctions(graph, fun);
        // Rename(graph);
        // CombineAddr(fun);
    }
    return prog;
}

static bool IsMemVariable(Box<ir::Stmt> stm) {
    auto alloca_stmt = stm->inner<ir::Alloca>();
    return stm->type() == ir::StmtKind::kAlloca &&
           alloca_stmt->dst()->kind() == ir::OperandKind::kLocal &&
           alloca_stmt->dst()->inner()->type() == ir::RegType::kIntPtr &&
           alloca_stmt->dst()->inner()->len() == 0;
}

void SSAWorker::CombineAddr(Box<ir::Func> fun) {
    unordered_map<Box<ir::LocalVal>, unordered_set<Box<Operand>>> local_set;
    unordered_map<Box<ir::GlobalVal>, unordered_set<Box<Operand>>> global_set;
    for (const auto& block : fun->blocks()) {
        auto instrs = block->instrs();
        for (const auto& stm : *instrs) {
            auto op_list =
                LivenessAnalysis::GetOps(stm, liveness::OpKind::kAll);
            for (auto op : op_list) {
                if (op->kind() == ir::OperandKind::kLocal) {
                    local_set[op->inner<ir::LocalVal>()].insert(op);
                } else if (op->kind() == ir::OperandKind::kGlobal) {
                    global_set[op->inner<ir::GlobalVal>()].insert(op);
                }
            }
        }
    }
    for (auto local : local_set) {
        auto first_op = **(local.second.begin());
        for (auto op : local.second) {
            *op = first_op;
        }
    }

    for (auto global : global_set) {
        auto first_op = **(global.second.begin());
        for (auto op : global.second) {
            *op = first_op;
        }
    }
}

void SSAWorker::PointerToReg(Box<ir::Func> fun) {
    /**
     * The `alias_map` helps transform scalars on the stack into scalars using
     * registers.
     *
     * - For an `alloca` instruction (scalar), the pointer allocated will be
     * mapped to a new local variable in the map.
     *
     * - For a `load` instruction from `ptr` to `dst`, we only care about `ptr`s
     * that were generated by `alloca` and are scalars. These `ptr`s are already
     * mapped to local variables in the map, and we can map `dst` to the same
     * local variable.
     *
     * - For a `store` instruction from `src` to `ptr`, the relevant `ptr`s have
     * already been mapped in the map. We can directly move `src` to the
     * underlying local variable of `ptr`.
     */
    std::unordered_map<Box<ir::Operand>, Box<ir::Operand>> alias_map;

    /**
     * First derive the `alias_map` by scanning the blocks.
     */
    for (auto& block : fun->blocks()) {
        for (const auto& inst : *block->instrs()) {
            switch (inst->type()) {
                case ir::StmtKind::kAlloca: {
                    /**
                     * We would only tackle scalar on stack.
                     */
                    if (inst->inner<ir::Alloca>()
                            ->dst()
                            ->inner<ir::LocalVal>() == nullptr) {
                        throw std::runtime_error(
                            "Attempting to alloca to an illegal operand.");
                    }
                    if (inst->inner<ir::Alloca>()
                            ->dst()
                            ->inner<ir::LocalVal>()
                            ->len() != 0) {
                        break;
                    }

                    auto dst_prev = inst->inner<ir::Alloca>()->dst();
                    auto dst_next =
                        Operand::FromLocal(ir::LocalVal::CreateInt());
                    alias_map[dst_prev] = dst_next;
                } break;
                case ir::StmtKind::kLoad: {
                    /**
                     * We will use `load` to access global variables, the `ptr`s
                     * of which should be replaced.
                     */
                    if (inst->inner<ir::Load>()->ptr()->kind() !=
                        ir::OperandKind::kLocal) {
                        break;
                    }

                    auto ptr_next = alias_map[inst->inner<ir::Load>()->ptr()];

                    /**
                     * The pointer `ptr` may be generated using `getelementptr`,
                     * which is outside the intended scope of this function's
                     * behavior.
                     */
                    if (ptr_next != nullptr) {
                        alias_map[inst->inner<ir::Load>()->dst()] = ptr_next;
                    }
                } break;
                default:
                    break;
            }
        }
    }

    auto fix_operands = [&alias_map](auto& ops) {
        for (auto& op : ops) {
            if (op->kind() == ir::OperandKind::kLocal &&
                op->inner<ir::LocalVal>()->type() == ir::RegType::kInt &&
                (alias_map.find(op) != alias_map.end())) {
                op = alias_map[op];
            }
        }
    };

    /**
     * The alias map is now derived, allowing us to start refactoring the
     * instructions. We handle different kinds of instructions as follows:
     *
     * - For `alloca`: Replace it with a move operation `0 -> val`.
     * - For `load`: Discard it since the alias relationships are recorded.
     * - For `store`: Replace it with a move operation `local_val -> target`.
     *
     * Note: We must address all local values, as they may have been generated
     * by a `load`. Since all `load` instructions have been removed, we resolve
     * these values using the alias map. Otherwise, unresolved local values
     * originating from `load` cannot be processed correctly.
     */
    for (auto& block : fun->blocks()) {
        for (auto& inst : *block->instrs()) {
            auto ops = LivenessAnalysis::GetOps(inst, liveness::OpKind::kAll);

            switch (inst->type()) {
                case ir::StmtKind::kAlloca: {
                    if (IsMemVariable(inst)) {
                        auto dst_next =
                            alias_map[inst->inner<ir::Alloca>()->dst()];
                        auto src = Operand::FromIConst(0);
                        inst = std::move(ir::Stmt::CreateMove(src, dst_next));
                    } else {
                        fix_operands(ops);
                    }
                } break;
                case ir::StmtKind::kLoad: {
                    continue;
                } break;
                case ir::StmtKind::kStore: {
                    if (inst->inner<ir::Store>()->ptr()->kind() !=
                        ir::OperandKind::kLocal) {
                        fix_operands(ops);
                        break;
                    }
                    auto ptr_next = alias_map[inst->inner<ir::Store>()->ptr()];
                    if (ptr_next == nullptr) {
                        fix_operands(ops);
                        break;
                    }
                    auto src_real = alias_map[inst->inner<ir::Store>()->src()];
                    auto src =
                        src_real ? src_real : inst->inner<ir::Store>()->src();
                    inst = std::move(ir::Stmt::CreateMove(src, ptr_next));
                } break;
                default: {
                    fix_operands(ops);
                } break;
            }
        }
    }
}

void SSAWorker::Dominators(utils::Graph<Box<ir::Block>>& bg) {
    assert(dominators_.size() == 0);
    auto sorted_nodes = bg.TopologicalSort();
#ifdef DEBUG
    int index = 0;
#endif
    for (const auto& node : sorted_nodes) {
#ifdef DEBUG
        assert(node->in_degree() <= index);
        index++;
#endif

        std::unordered_set<Box<ir::Block>> dom;
        for (const auto& id : node->predecessors()) {
            auto pre_node = bg.nodes().at(id);
            assert(dominators_.find(pre_node->element()) != dominators_.end());
            dom =
                common::set_intersection(dominators_[pre_node->element()], dom);
        }
        dom.insert(node->element());
        dominators_[node->element()] = dom;
    }
}

void SSAWorker::PrintDominators() {
    printf("Dominators:\n");
    for (auto x : dominators_) {
        printf("Dom(%s)={", x.first->label()->name().c_str());
        for (auto t : x.second) {
            printf("%s , ", t->label()->name().c_str());
        }
        if (x.second.size() >= 1) {
            printf("\b\b");
        }
        printf("}\n");
    }
}

void SSAWorker::PrintDominatorTree() {
    printf("Dominator tree:\n");
    for (auto x : tree_dominators_) {
        printf("%s ", x.first->label()->name().c_str());
        for (auto t : x.second->succs) {
            printf("%s ", t->label()->name().c_str());
        }
        printf("}\n\n");
    }
}
void SSAWorker::PrintDominaceFroniters() {
    printf("DF:\n");
    for (auto x : dominance_frontiers_) {
        printf("DF(%s)={", x.first->label()->name().c_str());
        for (auto t : x.second) {
            printf("%s , ", t->label()->name().c_str());
        }
        if (x.second.size() >= 1) {
            printf("\b\b");
        }
        printf("}\n");
    }
}

void SSAWorker::DeriveTreeDominators(Graph<Box<ir::Block>>& bg) {
    std::unordered_map<Box<ir::Block>, Box<ir::Block>> idom_map;
    for (const auto& [node, dominators] : dominators_) {
        std::unordered_set<Box<ir::Block>> rule_out;
        for (const auto& dominator : dominators) {
            if (dominator == node) continue;
            auto strict_dominate_set = dominators_[dominator];
            strict_dominate_set.erase(dominator);
            rule_out = common::set_union(rule_out, strict_dominate_set);
        }
        for (const auto& dominator : dominators) {
            if (dominator == node) continue;
            if (rule_out.find(dominator) != rule_out.end()) continue;
            idom_map[node] = dominator;
        }
    }

    for (const auto& [key, value] : idom_map) {
        if (tree_dominators_.find(key) == tree_dominators_.end()) {
            tree_dominators_[key] = std::make_shared<ImmediateDominator>();
        }
        if (tree_dominators_.find(value) == tree_dominators_.end()) {
            tree_dominators_[value] = std::make_shared<ImmediateDominator>();
        }
        assert(tree_dominators_[key]->pred == nullptr);
        tree_dominators_[key]->pred = value;
        tree_dominators_[value]->succs.insert(key);
    }
}

void SSAWorker::DeriveDominaceFroniters(Graph<Box<ir::Block>>& bg,
                                        Box<Node<Box<ir::Block>>> r) {
    std::unordered_set<Box<ir::Block>> df;
    for (const auto& id : r->successors()) {
        auto node = bg.nodes().at(id);
        if (dominators_[node->element()].find(r->element()) ==
            dominators_[node->element()].end()) {
            df.insert(node->element());
        }
    }

    for (const auto& child : tree_dominators_[r->element()]->succs) {
        if (dominance_frontiers_.find(child) == dominance_frontiers_.end()) {
            DeriveDominaceFroniters(bg, reverse_graph_[child]);
        }
        for (const auto& up : dominance_frontiers_[child]) {
            auto strict_dominators = dominators_[up];
            strict_dominators.erase(up);
            auto dnn = tree_dominators_[child]->pred;
            if (strict_dominators.find(dnn) == strict_dominators.end()) {
                df.insert(up);
            }
        }
    }

    dominance_frontiers_[r->element()] = df;
}

// 只对标量做
void PlacePhiFunctions(Graph<Box<ir::Block>>& bg, Box<ir::Func> fun) {
    //   Todo
}

/*static list<Box<ir::Operand>> get_def_int_operand(Box<ir::Stmt> stm) {
    list<Box<ir::Operand>> ret1 = get_def_operand(stm), ret2;
    for (auto AS_op : ret1) {
        if ((**AS_op).u.TEMP->type == TempType::INT_TEMP) {
            ret2.push_back(AS_op);
        }
    }
    return ret2;
}

static list<AS_operand**> get_use_int_operand(LLVMIR::L_stm* stm) {
    list<AS_operand**> ret1 = get_use_operand(stm), ret2;
    for (auto AS_op : ret1) {
        if ((**AS_op).u.TEMP->type == TempType::INT_TEMP) {
            ret2.push_back(AS_op);
        }
    }
    return ret2;
}

static void Rename_temp(GRAPH::Graph<LLVMIR::L_block*>& bg,
                        GRAPH::Node<LLVMIR::L_block*>* n,
                        unordered_map<Temp_temp*, stack<Temp_temp*>>& Stack) {
    //   Todo
}

void Rename(GRAPH::Graph<LLVMIR::L_block*>& bg) {
    //   Todo
}
*/